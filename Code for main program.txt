//
//  main.cpp
//  Lattice Tester
//

#include <iostream>
#include <string>
#include <iterator>
#include <set>

#include "latticetester/Normalizer.h"
#include "latticetester/Types.h"
#include "latticetester/Util.h"
#include "latticetester/Const.h"

#include "latticetester/Basis.h"
#include "latticetester/IntLattice.h"
#include "latticetester/Reducer.h"
#include "latticetester/Coordinates.h"

#include <time.h>

// for LLL test
#include <NTL/tools.h>
#include <NTL/ZZ.h>
#include <NTL/matrix.h>
#include "NTL/vec_ZZ.h"
#include <NTL/vec_vec_ZZ.h>
#include <NTL/mat_ZZ.h>
#include <NTL/LLL.h>

using namespace std;
using namespace LatticeTester;
using namespace NTL;


// TEST OF NORMALIZER
/*int main()
{
    const MScal m (101);
    int k (3);
    int maxDim (12);
    string Name ("MonNormaliseurDeMerde");
    NormType norm = L2NORM;
    double beta = 1.;
    
    Normalizer MonNormaliseur (m, k, maxDim, Name, norm, beta);
    
    MonNormaliseur.init(m,k,beta);
    
    cout << MonNormaliseur.ToString() << endl;
    cout << MonNormaliseur.getCst(11) << endl;
  
    cout << "** Fin du test **" << endl;
    return 0;
}*/


// TEST OF COORDINATES
/*int main()
{
    
    cout << "Test\t," << "bitch" << endl;
    cout << "Test   ," << "bitch" << endl;
    set<int> MonSet;
    MonSet.insert(2);
    MonSet.insert(5);
    MonSet.insert(7);
    //cin >> MonSet;
    //cout << MonSet << endl;
    
    
    
    Coordinates MyDefaultCoordinates;
    for (int k = 1; k < 7; k++){
        MyDefaultCoordinates.insert(k);
    }
    
    cout << MyDefaultCoordinates;
    cout << " (empty " << MyDefaultCoordinates.empty() << ")" << endl;
    MyDefaultCoordinates.clear();
    cout << MyDefaultCoordinates << endl;
    
    int indices [4];
    indices[0] = 0;
    indices[1] = 1;
    indices[2] = 6;
    indices[3] = 7;
    
    for (int idx = 0; idx < 4; idx++) {
        cout << "Test de présence de la valeur " << indices[idx];
        cout << " : " << *MyDefaultCoordinates.find(indices[idx]) << endl;
    }

    //cout << "-> ";
    operator<<(cout,"->");
    cin >> MyDefaultCoordinates;
    cout << MyDefaultCoordinates;
    cout << endl;
    
    for (int idx = 0; idx < 4; idx++) {
        cout << "Test de présence de la valeur " << indices[idx];
        cout << " : " << *MyDefaultCoordinates.find(indices[idx]) << endl;
    }
    
    cout << "-> ";
    cin >> MyDefaultCoordinates;
    cout << MyDefaultCoordinates << endl;

    
    //for (int i = 0; i < 6; i++){
        //cout << "Enter coordinates : ";
        //cin >> MyDefaultCoordinates;
        //cout << MyDefaultCoordinates << endl;
    //}

    //Coordinates::humanize = false;
    //cout << "Humanize : " << Coordinates::humanize << endl;
    
    //MyDefaultCoordinates.clear();
    //cout << MyDefaultCoordinates << endl;
    
    cout << "*Fin du test*" << endl;
    return 0;
}*/


// TEST TRIANGULARIZATION

/*void mywrite (Basis basis, string name, int m)
{
    cout << "\n" << name << " = " << endl;
    for (int i = 0; i < m; i++) {
        cout << "   | ";
        for (int j = 0; j < m; j++) {
            cout << setprecision (15) << basis(i,j) << "\t";
        }
        cout << " |" << endl;
    }
}
    
int main()
{
    int m = 2;
    
    Basis W(m,m);
    
    W(0,0)=2;   W(0,1)=0;
    W(1,0)=3;   W(1,1)=3;
    
    mywrite(W,"old W",m);
    
    Basis V(m,m);
    
    Triangularization(W, V, 2, 2, 11);
    
    mywrite(W,"new W",m);
    mywrite(V,"V",m);
    
    
    cout << "\n--fin--" << endl;
    return 0;
}*/

// TEST NTL EXPONENTIATION

/*int main()
{
    ZZ x;
    ZZ a_ntl (1263);
    long a = 0;
    conv(a,a_ntl);
    long e = 1000;
    power(x, a_ntl, e); // x = a^e (e >= 0)
    cout << "NTL : x = " << x << endl;
    cout << "Not : x = " << pow(a,e) << endl;
    
    return 0;
}*/


// TEST LLL

int main()
{
    const int max_dimension = 100;
    /*double TimerLLL [max_dimension];
    double TimerLLLNTL [max_dimension];
    bool EqualReducedBasis [max_dimension];
    
    for (int dimension = 1; dimension < max_dimension; dimension++){*/
        
        int modulus = 2;
        int dim = 50; //dimension
        double epsilon = 0.01;
        double delta = 1 - epsilon;
        
        int min = 1;
        int max = 500;
    
        Basis MyPrimalBasis (dim, L2NORM);
        srand (12345);
        for (int i = 0; i < dim; i++){
            for (int j = i; j < dim; j++)
                //MyPrimalBasis[i+1][j+1] = power_ZZ(i+1,j);
                MyPrimalBasis[i+1][j+1] = min + (rand() % (int)(max - min + 1));
        }
        //cout << "\nold Basis = " << endl;
        //MyPrimalBasis.write();
    
        IntLattice MyLattice (MyPrimalBasis, modulus);
        Reducer MyReducer (MyLattice);
    
        Basis MyPrimalBasisNTL (MyPrimalBasis);
        IntLattice MyLatticeNTL (MyPrimalBasisNTL,modulus);
        Reducer MyReducerNTL (MyLatticeNTL);
        //cout << "\nold NTLBasis = " << endl;
        //MyPrimalBasis.write();
    
        clock_t begin = clock();
    
        MyReducer.redLLL(delta,10000,dim);
        //cout << "\nnew Basis = " << endl;
        //MyLattice.getPrimalBasis().write();
    
        clock_t end = clock();
        
        MyReducerNTL.redLLLNTL(delta);
        //cout << "\nnew NTLBasis = " << endl;
        //MyLatticeNTL.getPrimalBasis().write();
    
        clock_t end2 = clock();
    
        double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
        double elapsed_secs2 = double(end2 - end) / CLOCKS_PER_SEC;
        bool test = MyLatticeNTL.getPrimalBasis() == MyLattice.getPrimalBasis();
        
        /*TimerLLL[dimension] = elapsed_secs;
        TimerLLLNTL[dimension] = elapsed_secs2;
        EqualReducedBasis[dimension] = test;*/
        
        cout << "Durée pour LatMRG = " << elapsed_secs << endl;
        cout << "Durée NTl = " << elapsed_secs2 << endl;
        cout << "Égalité des new Basis = " << test << endl;
        
    //} // end dimension loop
    
    /*cout << "\nTimerLLL = [";
    for (int j = 0; j < max_dimension; j++)
        cout << TimerLLL[j] << " ";
    cout << "]" << endl;
    
    cout << "\nTimerLLLNTL = [";
    for (int j = 0; j < max_dimension; j++)
        cout << TimerLLLNTL[j] << " ";
    cout << "]" << endl;
    
    cout << "\nEqualReducedBasis = [";
    for (int j = 0; j < max_dimension; j++)
        cout << EqualReducedBasis[j] << " ";
    cout << "]" << endl;*/

    // with NTL
    /*
    cout << "-------------- NTL --------------" << endl;
    
    mat_ZZ B;
    B.SetDims(4,4);
    B[0][0]=1; B[0][1]=2; B[0][2]=0; B[0][3]=0;
    B[1][0]=0; B[1][1]=1; B[1][2]=0; B[1][3]=0;
    B[2][0]=0; B[2][1]=0; B[2][2]=1; B[2][3]=0;
    B[3][0]=0; B[3][1]=0; B[3][2]=0; B[3][3]=1;
    B.SetDims(dim,dim);
    srand (12345);
    for (int i = 0; i < dim; i++){
        for (int j = i; j < dim; j++)
            //B[i][j] = power_ZZ(i+1,j);
            B[i][j] = min + (rand() % (int)(max - min + 1));
        }
    mat_ZZ U;
    U.SetDims(dim,dim);
    cout << "\nold B = " << endl;
    cout << B << endl;
    
    //[G_]LLL_{FP,QP,XD,RR} (mat_ZZ& B, [ mat_ZZ& U, ] double delta = 0.99,long deep = 0, LLLCheckFct check = 0, long verbose = 0);
    //LLL_XD(MyPrimalBasis, U, delta, 0,0,0);
    
    cout << "\nnew B = " << endl;
    cout << B << endl;
    //cout << "U = " << endl;
    //cout << U << endl;
     */
    return 0;
}


// TEST IMAGE AND KERNEL
/*
int main()
{
    int min = 0;
    int max = 100;
    srand(12345);
    
    int dim = 10;
    ZZ det;
    
    mat_ZZ B;
    B.SetDims(4,4);
     B[0][0]=1; B[0][1]=2; B[0][2]=0; B[0][3]=0;
     B[1][0]=0; B[1][1]=1; B[1][2]=0; B[1][3]=0;
     B[2][0]=0; B[2][1]=0; B[2][2]=1; B[2][3]=0;
     B[3][0]=0; B[3][1]=0; B[3][2]=0; B[3][3]=1;
    B.SetDims(dim,dim);
    for (int i = 0; i < dim; i++){
        for (int j = i; j < dim; j++)
            //B[i][j] = power_ZZ(i+1,j);
            B[i][j] = min + (rand() % (int)(max - min + 1));
    }
    
    cout << "\nold B = " << endl;
    cout << B << endl;
    
    determinant(det, B, 0);
    cout << "det = " << det << endl;
    ZZ det2 = det*det;
    
    mat_ZZ U;
    U.SetDims(dim,dim);
    
    long im;
    im = image(det2, B, U, 0);
    cout << "image = " << im << endl;
    
    cout << "\nnew B = " << endl;
    cout << B << endl;
    cout << "\nU = " << endl;
    cout << U << endl;
 
    cout << "\nold B = " << endl;
    cout << B << endl;
    
    //[G_]LLL_{FP,QP,XD,RR} (mat_ZZ& B, [ mat_ZZ& U, ] double delta = 0.99,long deep = 0, LLLCheckFct check = 0, long verbose = 0);
    LLL_XD(B, U, 0.99, 0,0,0);
    
    cout << "\nnew B = " << endl;
    cout << B << endl;
    //cout << "U = " << endl;
    //cout << U << endl;
 
    
    return 0;
}
*/




